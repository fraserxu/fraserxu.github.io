<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>CMD 模块定义规范</title>
  <meta name="author" content="Fraser Xu" />
  <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
  <link rel="stylesheet" href="/css/prettify.css" type="text/css" media="screen, projection" />
  <script type="text/javascript" src="/js/prettify.js"></script>
  <script type="text/javascript" src="/js/prettify-lua.js"></script>
</head>
<body onload="prettyPrint()">

  <div class="container">

    <div class="header">
      <h1><a href="/">Fraser Xu's</a></h1>
      <h2>Thoughts on life and code</h2>
    </div>

    <div class="nav">
      <a href="/">Cover</a>
      <a href="/archive.html">Archive</a>
      <a href="/about.html">About</a>
      <a href="/atom.xml">Subscribe</a>
    </div>

    <div class="content">
	<h1>CMD 模块定义规范</h1>
	<p class="meta">12 Sep 2013</p>
	<p>在 SeaJS 中，所有 JavaScript 模块都遵循 CMD（Common Module Definition） 模块定义规范。该规范明确了模块的基本书写格式和基本交互规则。</p>

<p>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：</p>

<p>define(factory);
define Function
define 是一个全局函数，用来定义模块。</p>

<p>define define(factory)</p>

<p>define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。</p>

<p>factory 为对象、字符串时，表示模块的接口就是该对象、字符串。比如可以如下定义一个 JSON 数据模块：</p>

<p>define({ &ldquo;foo&rdquo;: &ldquo;bar&rdquo; });
也可以通过字符串定义模板模块：</p>

<p>define(&lsquo;I am a template. My name is {{name}}.&rsquo;);
factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module：</p>

<p>define(function(require, exports, module) {</p>

<p>  // 模块代码</p>

<p>});
define define(id?, deps?, factory)</p>

<p>define 也可以接受两个以上参数。字符串 id 表示模块标识，数组 deps 是模块依赖。比如：</p>

<p>define(&lsquo;hello&rsquo;, [&lsquo;jquery&rsquo;], function(require, exports, module) {</p>

<p>  // 模块代码</p>

<p>});
id 和 deps 参数可以省略。省略 id 参数时，SeaJS 在加载时会用模块文件的访问路径作为模块标识。省略 deps 参数时，SeaJS 会自动提取 factory 函数中的 require(&lsquo;string&rsquo;) 来获取模块依赖。</p>

<p>在开发阶段，推荐不要手写 id 和 deps 参数，因为这两个参数可以在构建阶段通过工具自动生成。</p>

<p>注意：带 id 和 deps 参数的 define 用法不属于 CMD 规范，而属于 Modules/Transport 规范。</p>

<p>require Function
require 是 factory 函数的第一个参数。</p>

<p>require require(id)</p>

<p>require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口。</p>

<p>define(function(require, exports) {</p>

<p>  // 获取模块 a 的接口
  var a = require(&lsquo;./a&rsquo;);</p>

<p>  // 调用模块 a 的方法
  a.doSomething();</p>

<p>});
注意：在开发时，require 的书写需要遵循一些 简单约定。</p>

<p>require.async require.async(id, callback?)</p>

<p>require.async 方法用来在模块内部异步加载模块，并在加载完成后执行指定回调。callback 参数可选。</p>

<p>define(function(require, exports, module) {</p>

<p>  // 异步加载一个模块，在加载完成时，执行回调
  require.async(&lsquo;./b&rsquo;, function(b) {
    b.doSomething();
  });</p>

<p>  // 异步加载多个模块，在加载完成时，执行回调
  require.async([&lsquo;./c&rsquo;, &lsquo;./d&rsquo;], function(c, d) {
    c.doSomething();
    d.doSomething();
  });</p>

<p>});
注意：require 是同步往下执行，require.async 则是异步回调执行。require.async 一般用来加载可延迟异步加载的模块。</p>

<p>require.resolve require.resolve(id)</p>

<p>使用模块系统内部的路径解析机制来解析并返回模块路径。该函数不会加载模块，只返回解析后的绝对路径。</p>

<p>define(function(require, exports) {</p>

<p>  console.log(require.resolve(&lsquo;./b&rsquo;));
  // ==> http://example.com/path/to/b.js</p>

<p>});
这可以用来获取模块路径，一般用在插件环境或需动态拼接模块路径的场景下。</p>

<p>exports Object
exports 是一个对象，用来向外提供模块接口。</p>

<p>define(function(require, exports) {</p>

<p>  // 对外提供 foo 属性
  exports.foo = &lsquo;bar&rsquo;;</p>

<p>  // 对外提供 doSomething 方法
  exports.doSomething = function() {};</p>

<p>});
除了给 exports 对象增加成员，还可以使用 return 直接向外提供接口。</p>

<p>define(function(require) {</p>

<p>  // 通过 return 直接提供接口
  return {
    foo: &lsquo;bar&rsquo;,
    doSomething: function() {};
  };</p>

<p>});
如果 return 语句是模块中的唯一代码，还可简化为：</p>

<p>define({
  foo: &lsquo;bar&rsquo;,
  doSomething: function() {};
});
上面这种格式特别适合定义 JSONP 模块。</p>

<p>特别注意：下面这种写法是错误的！</p>

<p>define(function(require, exports) {</p>

<p>  // 错误用法！！!
  exports = {
    foo: &lsquo;bar&rsquo;,
    doSomething: function() {};
  };</p>

<p>});
正确的写法是用 return 或者给 module.exports 赋值：</p>

<p>define(function(require, exports, module) {</p>

<p>  // 正确写法
  module.exports = {
    foo: &lsquo;bar&rsquo;,
    doSomething: function() {};
  };</p>

<p>});
提示：exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。</p>

<p>module Object
module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</p>

<p>module.id String</p>

<p>模块的唯一标识。</p>

<p>define(&lsquo;id&rsquo;, [], function(require, exports, module) {</p>

<p>  // 模块代码</p>

<p>});
上面代码中，define 的第一个参数就是模块标识。</p>

<p>module.uri String</p>

<p>根据模块系统的路径解析规则得到的模块绝对路径。</p>

<p>define(function(require, exports, module) {</p>

<p>  console.log(module.uri);
  // ==> http://example.com/path/to/this/file.js</p>

<p>});
一般情况下（没有在 define 中手写 id 参数时），module.id 的值就是 module.uri，两者完全相同。</p>

<p>module.dependencies Array</p>

<p>dependencies 是一个数组，表示当前模块的依赖。</p>

<p>module.exports Object</p>

<p>当前模块对外提供的接口。</p>

<p>传给 factory 构造方法的 exports 参数是 module.exports 对象的一个引用。只通过 exports 参数来提供接口，有时无法满足开发者的所有需求。 比如当模块的接口是某个类的实例时，需要通过 module.exports 来实现：</p>

<p>define(function(require, exports, module) {</p>

<p>  // exports 是 module.exports 的一个引用
  console.log(module.exports === exports); // true</p>

<p>  // 重新给 module.exports 赋值
  module.exports = new SomeClass();</p>

<p>  // exports 不再等于 module.exports
  console.log(module.exports === exports); // false</p>

<p>});
注意：对 module.exports 的赋值需要同步执行，不能放在回调函数里。下面这样是不行的：</p>

<p>x.js</p>

<p>define(function(require, exports, module) {</p>

<p>  // 错误用法
  setTimeout(function() {
    module.exports = { a: &ldquo;hello&rdquo; };
  }, 0);</p>

<p>});
y.js</p>

<p>define(function(require, exports, module) {</p>

<p>  var x = require(&lsquo;./x&rsquo;);</p>

<p>  // 无法立刻得到模块 x 的属性 a
  console.log(x.a); // undefined</p>

<p>});
module.destroy Function</p>

<p>在模块系统中注销当前模块。</p>

<p>有时候我们需要重新加载某个模块，这时可以：</p>

<p>// 通过 url 拿到模块
var mod = seajs.cache[uri];</p>

<p>// 从模块系统中销毁掉
mod.destroy();</p>

<p>// 这时会重新加载文件
seajs.use(uri, callback);
小结
这就是 CMD 模块定义规范的所有内容。经常使用的 API 只有 define, require, require.async, exports, module.exports 这五个。其他 API 有个印象就好，在需要时再来查文档，不用刻意去记。</p>

<p>与 RequireJS 的 AMD 规范相比，CMD 规范尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。通过 CMD 规范书写的模块，可以很容易在 Node.js 中运行，后续会介绍。</p>

</div>

<div class="related">
  <h2>~ Related ~</h2>
  <ul class="posts">
    
      <li><span>12 Sep 2013</span> · <a href="/posts/Using-Handlebarsjs-with-Expressjs">在Express项目中使用Handlebars模板引擎</a></li>
    
      <li><span>07 Aug 2013</span> · <a href="/posts/Form-validation-with-AngularJS">AngularJS表单验证</a></li>
    
      <li><span>22 Jun 2013</span> · <a href="/posts/Nginx-for-developers">写给Web开发人员看的Nginx介绍</a></li>
    
      <li><span>07 Jun 2013</span> · <a href="/posts/understanding-expressjs">(譯)深入理解Express.js</a></li>
    
      <li><span>07 Jun 2013</span> · <a href="/posts/thoughts-of-these-days">Life Sucks</a></li>
    
  </ul>
</div>

  </div>
</body>
</html>
